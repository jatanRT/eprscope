---
title: "First Steps"
output: 
  bookdown::html_document2:
    base_format: rmarkdown::html_vignette
    mathjax: "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
    self_contained: TRUE
number_sections: TRUE
fig_caption: TRUE
link-citations: TRUE
bibliography: firstSteps.bib
csl: iso690-numeric-en.csl
vignette: >
  %\VignetteIndexEntry{First Steps}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
pkgdown:
  as_is: TRUE
---

```{r knitr-setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  webshot = "webshot",
  fig.width = 7.2,
  fig.height = 4.8
)
options(
  rmarkdown.html_vignette.check_title = FALSE
)
```

$\require{mhchem}$

```{r setup, include = FALSE}
library(eprscope)
library(knitr)
library(patchwork)
library(htmlwidgets)
library(plotly)
```

# Installation Details

Prior to own `{eprscope}` ðŸ“¦ installation a minimal system setup is required and can be followed by these steps:

1.  Installation of *JDK Development Kit* where the corresponding package, suitable for your operating system, can be downloaded from the [official *Oracle* website](https://www.oracle.com/java/technologies/downloads/?er=221886).

2.  Please, follow the instructions for the [base ![](RcoreLogo.png){width="16" height="12"} installation and setup](https://cran.r-project.org/).

3.  Download and install [*RStudio IDE*](https://posit.co/download/rstudio-desktop/) (Integrated Development Environment).

4.  Download and install the latest release of [*Rtools* (WINDOWS only)](https://cran.r-project.org/bin/windows/Rtools/) or on *macOS/Linux* [follow the instructions to install *CMake*](https://astamm.github.io/nloptr/). Alternatively, on *macOS*, *CMake* can be set up through the [Homebrew](https://brew.sh/) repository (see also <https://formulae.brew.sh/formula/cmake#default>). This step is required to use the `{nloptr}` ðŸ“¦ for the fitting of EPR spectra.

5.  In the ![](RcoreLogo.png){width="16" height="12"} *Console* (lower left panel within the *RStudio IDE*) run the following code in order to install essential ![](RcoreLogo.png){width="16" height="12"} packages for data science with all their dependencies âž¨

    ```{r essential-r-packages,eval = FALSE,echo = TRUE}

    install.packages("tidyverse",dependencies = TRUE)
    #
    # additional packages required by the `{eprscope}`:
    install.packages(
      c("DT","vctrs","npreg","patchwork","kableExtra",
        "htmlwidgets","webshot2","tinytable","gsignal",
        "shiny","shinythemes"),
      dependencies = TRUE
    )

    ```

There are two options how to install the `{eprscope}` ðŸ“¦ via the ![](RcoreLogo.png){width="16" height="12"} *Console* âž¨

```{r install-eprscope-01-opt,eval = FALSE,echo = TRUE}

# from the GitHub repository:
if (!require(devtools)) {install.packages("devtools")}
devtools::install_github("jatanRT/eprscope")

```

or

```{r install-eprscope-02-opt,eval = FALSE,echo = TRUE}

# from the R-Universe (https://r-universe.dev/search)
# and CRAN (https://cran.r-project.org/) repositories:
install.packages(
  "eprscope",
  repos = c(
    "https://jatanrt.r-universe.dev",
    "https://cloud.r-project.org"
  )
)

```

If one wants to install the entire ðŸ“¦ including all the documentation vignettes/articles âž¨

```{r install-eprscope-03-opt,eval = FALSE,echo = TRUE}

if (!require(devtools)) {install.packages("devtools")}
devtools::install_github("jatanRT/eprscope",build_vignettes = TRUE)

```

# First Steps in ![](RcoreLogo.png){width="28" height="21"} Statistical Language

In this section, only essential syntax and/or basic commands to run the `{eprscope}` functions will be described. For details or more advanced programming experience, please refer to the resources in [*README* file/Homepage](https://jatanrt.github.io/eprscope/index.html).

## Variable/Function Names and Assignment

Any name, even the complex one (see vide infra), can be applied to assign the variables/functions. It is common to use complex names with the parts separated either by underscore `..._...` or by point, like stated in the examples below. Both assignment operators (`<-` and `=`) can be used in ![](RcoreLogo.png){width="16" height="12"} language. However, the application of the first one is preferred, due to the fact that the `=` is a pure assignment operator and it does not necessarily initialize a variable in the namespace (e.g. as arguments in a function, see below). Whereas, the `<-` always creates a variable [@assignR2018; @assignRb; @RPeters2020; @wickham2019]. In order to improve the code readability, comments might be included, starting the line with the hash symbol `#` like already shown in the installation code above.

```{r names-assignments}

# Q value (EPR sensitivity instrumental factor) assignment:
Q_value <- 3500
#
# loading package built-in example file/data => "TMPD_specelchem_accu_b.asc",
# which corresponds to EPR spectrum of Wuster's blue:
tmpd.data.file <- load_data_example(file = "TMPD_specelchem_accu_b.asc")

```

The `file` within the parentheses represents an **argument of the function** `load_data_example()` and **its assignment must be solely provided by the `=` operator.** If several arguments are defined, they have to be separated by `,` ("comma").

## Functions and Packages

Packages are fundamental units of shareable code. They may bundle functions, sample code, datasets, documentation and tests [@GfG2023; @wickham2023]. By default, during the ![](RcoreLogo.png){width="16" height="12"} installation, only a couple of packages are set up (e.g. `{base}` , `{datasets}` , `{graphics}` , `{grdevices}` , `{stats}` , `{utils}` ). These are also immediately available, once you start the ![](RcoreLogo.png){width="16" height="12"} console. Additional packages must by installed and loaded explicitly in order to be utilized. To load such packages, the function `library()` have to be executed. It actually refers to the (default) place (folder) where the ðŸ“¦ is stored on your computer, such as loading collection of the essential data science packages ([{tidyverse}](https://www.tidyverse.org/), already mentioned above):

```{r loading-tidyverse}

library(tidyverse)

```

Sometimes a function/dataset/object from a certain ðŸ“¦ is called via "special" syntax like `package::function()`. The double colon `::` actually points to selection from the package `NAMESPACE` in order to prevent collisions when functions/datasets/objects from different packages possess the same name (e.g. `stats::filter()` and `dplyr::filter()` , see also the massage after `{tidyverse}` loading, above)[^1]. However, in most cases, one does not need to call each function like this and it is enough if `library(package)` command is executed at the beginning of the entire ![](RcoreLogo.png){width="16" height="12"} script (which is also the case for the `{eprscope}` ðŸ“¦).

[^1]: On the rare occasions you may also come across the triple colon `:::` which calls the "hidden" objects from the package (e.g. installation of several $\LaTeX$ packages under the ![](RcoreLogo.png){width="16" height="12"} `tinytex` distribution: `tinytex:::install_yihui_pkgs()` , see also <https://yihui.org/tinytex/>)

## Vectors and Matrices

In order to hold multiple data values of the same type (e.g. numeric, character or logical) the ![](RcoreLogo.png){width="16" height="12"} language uses the vector object, which is created by the `c(...)` command/function (the "c" stands for "combine" or "concatenate") like:

```{r creating-vector}

# creating a vector of EPR intensity 
# normalization constant names:
str.norm <- c("NumberOfScans","Concentration","QValue")
#
# ...and their corresponding values:
value.norm <- c(24,1e-3,3500)
#
# preview of both vectors:
str.norm
value.norm

```

The combination of different types automatically turns the vector components into character:

```{r creating-vector-combination}

# combination/concatenation of both
# vectors created above:
comb.norm <- c(str.norm,value.norm)
#
# preview
comb.norm

```

To avoid such behavior one has to define a `list` as shown below. The length of a vector can be figured out by the `length()` function, counting the number of vector components:

```{r vector-length}

# dermine the vector length (`comb.norm`):
length(comb.norm)

```

Performing operations on individual elements requires indexing (vectors in ![](RcoreLogo.png){width="16" height="12"} are 1 based indexing unlike the normal *C* or *Python*), which is quite simple and demonstrated on the following examples:

```{r vector-element-operations}

# select the third element:
comb.norm[3]
#
# select the last element:
comb.norm[length(comb.norm)]
#
# remove the second and the fifth  element:
comb.norm[-c(2,5)]
#
# ...or the same selection 
# by logical operations:
comb.norm[c(TRUE,FALSE,TRUE,TRUE,FALSE,TRUE)]
#
# replace the fourth element:
comb.norm[4] <- 50 # or "50"
#
# the actual `comb.norm` vector
# (with replacement of the 4th element):
comb.norm

```

The basic arithmetic operations on vectors are also performed element-wise:

```{r vector-basic-operations}

# create vector of 10 numeric values,
# repeating `0.1` 10-times:
vec.01 <- rep(0.1,times = 10)
#
# vector of B_{central} (magnetic flux density) 
# in Gauss to calculate the g_{iso} values:
B.central.vec <- c(
  3485.22,3490.47,3491.78,3488.35,3492.55,
  3489.21,3491.99,3491.47,3492.50,3490.23
)
#
# addition (+ preview):
add.vec <- vec.01 + B.central.vec
add.vec
#
# multiplication (+ preview, values in mT): 
multiple.vec <- vec.01 * B.central.vec
multiple.vec
#
# microwave frequency to calculate the g_{iso}:
nu.GHz <- 9.892546
#
# operation (calculate g_{iso}) in a loop, iteration
# through all elements (i) of the `B.central.vec`:
vec.g.iso.a <- sapply(
  B.central.vec, {function(i) 
    eval_gFactor(
      nu.val = nu.GHz,
      B.val = i,
      B.unit = "G"
    )}
)
# such operation is an equivalent 
# (simplification of) to `for` loop:
vec.g.iso.b <- c()
for (i in seq(B.central.vec)) {
  vec.g.iso.b[i] <- eval_gFactor(
    nu.val = nu.GHz,
    B.val = B.central.vec[i],
    B.unit = "G"
  )
}
# preview (comparison):
vec.g.iso.a
identical(vec.g.iso.a,vec.g.iso.b) # Are these vectors identical ?

```

Previous examples show how the vectors can be created by `loops` , however in to order to calculate the *g*~iso~-values, one can just simply apply the `eval_gFactor()` function on the entire `B.central.vec` like:

```{r simple-g-iso}

vec.g.iso.c <- eval_gFactor(
  nu.val = nu.GHz,
  B.val = B.central.vec,
  B.unit = "G"
)
# preview:
vec.g.iso.c

```

Matrices can be created from vectors as demonstrated by the following example:

```{r creation-of-matrices}

# define vector (sequence) of hypothetical g-values:
mat.01.vec <- seq(2.001,2.009,length.out = 9)
#
# create 3 x 3 matrix with `mat.01.vec` 
# elements arranged in rows:
mat.01 <- matrix(mat.01.vec,3,3,byrow = TRUE)
#
# preview:
mat.01
#
# 3 x 3 diagonal identity matrix:
mat.02 <- diag(nrow = 3,ncol = 3)
#
# preview:
mat.02
#
# create matrix from the vectors 
# bound into columns (see the next operation):
mat.02.vec <- c(2.0033,2.0034)
mat.03.vec <- c(2.0035,2.0036)
#
# ...and the corresponding matrix:
mat.03 <- cbind( # "c" for column
  mat.02.vec,
  mat.03.vec,
  deparse.level = 0 # no labels
)
# similarly, the matrix can be also created,
# from vectors bound into rows,
# by the `rbind()` function
#
# preview of `mat.03`:
mat.03

```

Selection of elements is similar to that of vectors with additional second dimension:

```{r selections-in-matrices}

# select element in the 2nd row
# and the 3rd column within `mat.01`:
mat.01[2,3]
#
# subset 2 x 2 matrix from
# the `mat.01`:
mat.01[1:2,1:2]

```

Transpose the `mat.01` matrix:

```{r matrix-transposition}

# `mat.01` transposition:
mat.01.t <- t(mat.01)
#
# preview:
mat.01.t

```

Inverse matrix ($A^{-1}$) can be obtained by the `solve()` (`{base}` package) function, where $A^{-1}\,A = A\,A^{-1}\,=\mathrm{1}$ (identity matrix):

```{r inverse-matrix}

# 3 x 3 matrix of magnetic flux density:
A <- matrix(B.central.vec[1:9],3,3)
#
# inverse matrix:
A_1 <- solve(A)
#
# preview:
A_1
#
# check if A_1 * A = 1,
# by matrix multiplication (A_1 %*% A):
identical(
  diag(nrow = 3,ncol = 3),
  round(A_1 %*% A,digits = 8) # rounding to 8 decim. places
) # Are matrices identical ?

```

The inverse matrix calculation requires following condition:

```{r determinant}

# determinat of A matrix must be different from 0:
isFALSE(det(A) == 0)

```

## Data Frames and the Pipe Operator

Data frame is one of most important structures/objects in ![](RcoreLogo.png){width="16" height="12"} statistical language to store the tabular data/dataset. It is similar to matrix (because it is an 2-dimensional scheme), but unlike the matrices it can take different data types in lists (vide infra) of vectors with the equal lengths, corresponding **to columns/variables**. The second dimension is defined by the **rows/observations**, consisting of vector elements with equal indices (from all columns). As an example we may construct data frame directly by the `readEPR_Exp_Specs()` function from `{eprscope}` ðŸ“¦:

```{r create-df-example-01}

# read the EPR spectrum from the already 
# defined path `tmpd.data.file`:
df.example.01 <- readEPR_Exp_Specs(
  tmpd.data.file,
  col.names = c("B_G","dIepr_over_dB"),
  qValue = Q_value, # defined above
  origin = "winepr"
)
#
# preview (first 6 rows)
head(df.example.01)

```

The previous data frame consists of the following columns/variables represented by their headers:

```{r df-example-01-headers}

# headers for 2D schemes like matrices or data frames:
colnames(df.example.01)
#
# ...or in general:
names(df.example.01)

```

These column names are referred to the following vectors:

1.  Magnetic flux density $\small B$ in Gauss (`B_G`)

2.  Derivative EPR intensity (`dIepr_over_dB`) in p.d.u. (processing defined units [@HansIUPAC2019])

3.  Magnetic flux density $\small B$ in millitesla (`B_mT`)

One can preview the **str**ucture of data frame by the `str()` function from the `{utils}` ðŸ“¦:

```{r df-example-01-structure}

str(df.example.01)

```

We can immediately recognize that all three columns are **num**eric and the dimension (which can be also figured out by the `dim()` function) reads 2401 (rows/observations) $\small \times$ 3 (variables/columns). The dollar sign `$` in front of each column vector represent an operator to select the column (variable) of a data frame, namely:

```{r df-example-01-select-col-a}

# vector of magnetic flux density in G:
vec.B.G.a <- df.example.01$B_G
#
# preview of the first 12 values:
vec.B.G.a[1:12]

```

Similarly, the same vector/column can be also selected by double square brackets `[[]]` , like:

```{r example-01-select-col-b}

vec.B.G.b <- df.example.01[[1]]
# or
vec.B.G.c <- df.example.01[["B_G"]]
#
# preview of the first 12 values:
vec.B.G.b[1:12]
vec.B.G.c[1:12]

```

In order to select/convert a data frame row into vector one has to, first of all, `unlist()` the row (because it possesses the form of data frame) and finally remove the names:

```{r exxample-01-df-row-vector}

# first row of data frame:
df.example.01[1, ]
#
# convert the row data frame 
# into the vector:
unname(unlist(df.example.01[1, ]))

```

Selection/Subset by single square brackets results in data frame structure, even with one row or column/variable, which is kind of similar to matrices, as already depicted above. An alternative way would be the usage of `subset()` function from the `{base}` ðŸ“¦. Both ways are documented by the following code:

```{r example-01-select-fiter-df}

# select the first column,
# resulting in data frame:
head(df.example.01[ ,1])
#
# select the 4th row of the original
# data frame and extract the `B_mT` value:
df.example.01[4, ][["B_mT"]]
#
# select and/or subset data frame
# with magnetic flux density `B_G` <= `Bcf`,
# which is the central field (or `median(B_G)`):
head(df.example.01[df.example.01$B_G <= median(df.example.01$B_G), ])
#
# the same with `subset()`:
head(subset(df.example.01,B_G <= median(B_G)))

```

To create or delete a column/variable one may use:

```{r example-01-creat-del-col}

# create g-value column (`g_Val`):
df.example.01$g_Val <- # or `df.example.01[["g_Val"]] <-`
  eval_gFactor(
    nu.val = nu.GHz,
    B.val = df.example.01$B_mT
  )
#
# ...right after that delete
# the `B_mT` column/variable:
df.example.01$B_mT <- NULL
#
# ...the same operation can be done
# by: `df.example.01[,-3]` or 
# `subset(df.example.01,select = -B_mT)`
#
# data frame preview
head(df.example.01)

```

A data frame can be also created, by definition (see above), using equally long vectors (refer to the vector definition at the beginning of this vignette), like:

```{r create-df-from-vectors}

# create a data frame by the `data.frame()` base 
# function using the vectors already defined above:
normalization.df <- data.frame(
  norm_names = str.norm,
  norm_values = value.norm
)
#
# preview:
normalization.df

```

**Pipe Operator(s) `%>%` (or `|>`) in** ![](RcoreLogo.png){width="16" height="12"} **Programming Language**

In order understand where does these operators come from we may start with a brief historical background [@dataCamp2022pipe]. The basic principle actually comes from mathematics. If two functions (e.g. $\small f : B \rightarrow C$ and $\small g : A\rightarrow B$) are linked together into an operational chain, the output from one ($\small g$) serves as an input for the other ($\small f$), resulting in $\small f(g(x))$, where $\small x\equiv A$, $\small g(x)\equiv B$ and $\small f(g(x))\equiv C$. The pipe operator is also well known in other programming languages (e.g. in *Python* or *Julia* ) and/or in the *Shell*/*Terminal*. However, it may possess a different syntax in comparison to ![](RcoreLogo.png){width="16" height="12"} [^2]. Its broad range of applications actually started in 2013-2014 by development of [{magrittr}](https://magrittr.tidyverse.org/) and [{dplyr}](https://dplyr.tidyverse.org/) packages in order to express sequences of operations in a readable and concise way. **For beginners in programming, one might imagine the "pipe" as a command (or narrator), saying: "...and then..." where in the background it takes the result on its left side and passes it as a first argument to the function on its right-hand side** (see examples below)**. This allows users to avoid creation of intermediate variables, makes the code easier to follow and finally also reduces the likelyhood of a bug appearence.**

[^2]: One may come across symbols like `.` , `>>` , `|>` or `|`

For the simple cases both `%>%` and `|>` (the latter, also known as a native pipe operator) behave identically. However, they differ...

## Lists

Blah

## Plots

Blah

## Basic String Operations

Blah

# References
