% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eval_sim_EPR_isoFit_space.R
\name{eval_sim_EPR_isoFit_space}
\alias{eval_sim_EPR_isoFit_space}
\title{Explore the Hyperspace of Initial EPR Simulation Parameters (Searching for the Best Fit)}
\usage{
eval_sim_EPR_isoFit_space(
  data.spectr.expr,
  nu.GHz,
  B.unit = "G",
  nuclear.system.noA = NULL,
  baseline.correct = "constant",
  lineG.content = 0.5,
  lineG.content.dvary = NULL,
  lineSpecs.form = "derivative",
  optim.method = "neldermead",
  optim.params.init,
  optim.params.init.dvary = NULL,
  Nmax.evals = 256,
  N.points.space = 16,
  check.fit.plot = TRUE,
  processing = "sequential",
  animation = "Fitting_of_sim_EPR",
  ...
)
}
\arguments{
\item{data.spectr.expr}{Data frame object/table, containing the experimental spectral data with the magnetic flux density
(\code{"B_mT"} or \code{"B_G"}) and the intensity (see the \code{Intensity.expr} argument) columns.}

\item{nu.GHz}{Numeric value, microwave frequency in \code{GHz}.}

\item{B.unit}{Character string, denoting the magnetic flux density unit e.g. \code{B.unit = "G"}
(gauss, \strong{default}) or \code{B.unit = "mT"}/\code{"T"} (millitesla/tesla).}

\item{nuclear.system.noA}{List or nested list \strong{without estimated hyperfine coupling constant values},
such as \code{list("14N",1)} or \code{list(list("14N", 2),list("1H", 4),list("1H", 12))}. The \eqn{A}-values
are already defined as elements of the \code{optim.params.init} argument/vector. If the EPR spectrum
does not display any hyperfine splitting, the argument definition reads \code{nuclear.system.noA = NULL} (\strong{default}).}

\item{baseline.correct}{Character string, referring to baseline correction of the simulated/fitted spectrum.
Corrections like \code{"constant"} (\strong{default}), \code{"linear"} or \code{"quadratic"} can be applied.}

\item{lineG.content}{Numeric value between \code{0} and \code{1}, referring to content of the \emph{Gaussian} line form.
If \code{lineG.content = 1} (\strong{default}) it corresponds to "pure" \emph{Gaussian} line form
and if \code{lineG.content = 0} it corresponds to \emph{Lorentzian} one. The value from (0,1)
(e.g. \code{lineG.content = 0.5}) represents the linear combination (for the example above,
with the coefficients 0.5 and 0.5) of both line forms => so called \emph{pseudo-Voigt}.}

\item{lineG.content.dvary}{Numeric value, corresponding to initial \strong{var}iation of \code{lineG.content},
(Gaussian EPR line content in the simulated EPR spectrum) provided as \eqn{\pm} \strong{d}ifference
of the central \code{lineG.content} value. For example, if \code{lineG.content = 0.42}
and \code{lineG.content.dvary = 0.2}, the parameter will be varied within the range of \eqn{0.42\pm 0.2},
which will be divided into \code{N.points.space} points (like already shown for the example
in the \code{N.points.space} argument description). \strong{Default}: \code{lineG.content.dvary = NULL},
actually pointing to constant \code{lineG.value} throughout the space (optimization/fitting procedures).}

\item{lineSpecs.form}{Character string, describing either \code{"derivative"} (\strong{default})
or \code{"integrated"} (i.e. \code{"absorption"} which can be used as well) line form
of the analyzed EPR spectrum/data.}

\item{optim.method}{Character string (vector), setting the optimization method(s) gathered within
the \code{\link{optim_for_EPR_fitness}}. \strong{Default}: \code{optim.method = "neldermead"}. Additionally,
several consecutive methods can be defined like \code{optim.method = c("levenmarq","neldermead")}, where
the best fit parameters from the previous method are used as input for the next one.}

\item{optim.params.init}{Numeric vector with the initial parameter guess (elements) where the \strong{first five
  elements are immutable}
  \enumerate{
  \item g-value (g-factor)

  \item \strong{G}aussian linewidth

  \item \strong{L}orentzian linewidth

  \item baseline constant (intercept or offset)

  \item intensity multiplication constant

  \item baseline slope (only if \code{baseline.correct = "linear"} or \code{baseline.correct = "quadratic"}),
  if \code{baseline.correct = "constant"} it corresponds to the \strong{first HFCC} (\eqn{A_1})

  \item baseline quadratic coefficient (only if \code{baseline.correct = "quadratic"}),
  if \code{baseline.correct = "constant"} it corresponds to the \strong{second HFCC} (\eqn{A_2}),
  if \code{baseline.correct = "linear"} it corresponds to the \strong{first HFCC} (\eqn{A_1})

  \item additional HFCC (\eqn{A_3}) if \code{baseline.correct = "constant"} or if
  \code{baseline.correct = "linear"} (\eqn{A_2}), if \code{baseline.correct = "quadratic"} it corresponds
  to the \strong{first HFCC} (\eqn{A_1})

  \item ...additional HFCCs (\eqn{A_k...}, each vector element is reserved only for one \eqn{A})
  }
  DO NOT PUT ANY OF THESE PARAMETERS to \code{NULL}. If the lineshape is expected to be pure
  \strong{L}orentzian or pure \strong{G}aussian then put the corresponding vector element to \code{0}.}

\item{optim.params.init.dvary}{Numeric vector with initial \strong{var}iations of the corresponding
\code{optim.params.init} elements in the form of \strong{d}ifferences from the central \code{optim.params.init}
values. For example, for the aminoxyl radical we may assume \code{optim.params.init = c(2.006,4.8,4.8,0,1.4e-2,49)}
(see the \code{optim.params.init} argument definition). Thus, the \code{optim.params.init.dvary} could be defined
as follows: \code{c(0.002,2.0,2.0,0,1e-2,3.2)}, meaning that \eqn{g = 2.006\pm 0.002},
\eqn{\Delta B_{\text{pp}}^{\text{G}} = 4.8\pm 2.0\,\text{G}},
\eqn{\Delta B_{\text{pp}}^{\text{L}} = 4.8\pm 2.0\,\text{G}}, constant baseline \eqn{0\pm 0}, ...etc.
The user may "fix" one or more initial parameter values by putting the corresponding \code{optim.params.init.dvary}
element to \code{0}. However, this does not fix that (those) parameter(s) in a true sense. Rather, the \strong{initial}
parameter \strong{value remains constant} over the whole space (however, it will be optimized within
the default bound constraints anyway, see the \code{\link{eval_sim_EPR_isoFit}} documentation). If one really wants
to fix one or more parameters (which won't be optimized) an optional \code{optim.params.fix.id} (see also description
of the \code{...} argument) should be used together with \code{0} of the corresponding \code{optim.params.init.dvary}
element. For example, to fix the g-Value (i.e. it won't be optimized) of the above-described aminoxyl, one must add
\code{optim.params.fix.id = 1} and \code{optim.params.init.dvary = c(0,2.0,2.0,0,1e-2,3.2)}.
If the entire \code{optim.params.init} argument is to be "fixed" => put
\code{optim.params.init.dvary = NULL} (\strong{default}). In all cases, the related \code{optim.params.init}
space will be created as a matrix or data frame (see also the \code{Value}/\code{init.space.df}) with
variables/columns corresponding to individual parameters, and observations/rows corresponding
to each \code{N.points.space}, dividing the parameter variation range (e.g \eqn{g = 2.006\pm 0.002})
into smaller spaces. Therefore, the fitting process will be performed (by the default \code{\link{eval_sim_EPR_isoFit}}
configuration) for each row of the initial data frame (\code{init.space.df}) together with the initial \code{lineG.content}
variation vector (see the description of \code{N.points.space} and \code{lineG.content.dvary} arguments).
For the \code{optim.params.init.dvary = NULL}, the fitting procedure is just repeated
\code{N.points.space}-times, with the same parameter set. Such processing might be useful to determine
the uncertainty of each optimized EPR simulation parameter by the \code{\link{eval_interval_cnfd_tVec}}
for each column of the \code{optim.space.df} (see the \code{Value}).}

\item{Nmax.evals}{Numeric value, maximum number of function evaluations and/or iterations.
The only one method, limited by this argument, is \code{\link[minpack.lm]{nls.lm}}, where
\code{Nmax.evals = 1024}. Higher \code{Nmax.evals} may extremely extend the optimization
time, therefore the \strong{default} value reads \code{Nmax.evals = 512}. However, the \code{"pswarm"}
method requires at least the default or even higher values.}

\item{N.points.space}{Numeric value, identical to number of points by which the initial parameter-hyperspace
(see the \code{lineG.content.dvary} and/or \code{optim.params.init.dvary} and their corresponding
\code{lineG.content} as well as \code{optim.params.init} arguments)
is divided, in order to find the best optimized parameters for EPR simulation fit of the isotropic
experimental spectrum. \strong{Default}: \code{N.points.space = 16}, e.g. if \code{lineG.content = 0.42}
and \code{lineG.content.dvary = 0.2}, the initial corresponding vector looks like
\code{c(0.220,0.247,0.273,0.300,0.327,...,0.567,0.593,0.620)}, where the length of this vector is equal
to \code{N.points.space = 16}.}

\item{check.fit.plot}{Logical, whether to return overlay plot with the initial simulation + the best simulation
fit + experimental spectrum (including residuals in the lower part of the plot,
\code{check.fit.plot = TRUE}, \strong{default}) or with the following three spectra
(\code{check.fit.plot = FALSE}): 1. experimental, 2. the best simulated one with the baseline fit
and 3. the best simulated spectrum with the baseline fit subtracted. The latter two are offset for clarity,
within the plot.}

\item{processing}{Character string, corresponding to \code{"sequential"} (\strong{default} traditional
computing method), or \code{"parallel"} processing/evaluation of EPR spectrum fit (optimization of parameters).
The latter dramatically speeds up the execution time for all points (see the \code{N.points.space}
argument) of the initial parameter-hyperspace, by dividing all the loops/iterations/evaluations
into smaller sub-tasks, which are processed simultaneously. When selecting
\href{https://grantmcdermott.com/ds4e/parallel.html}{parallel processing},
the function/script automatically detects the number of CPU cores of your machine and selects half of them
(e.g. for 4 cores in total, 2 cores are selected) for the computation. Otherwise, if the hardware resources
are limited (2 cores in total), the \code{processing = "parallel"} automatically switches
to \code{"sequential"} mode.}

\item{animation}{Character string, pointing to name of the animated \code{.gif} file, returned
after processing and stored in the working directory (see the \code{Value}). If the animation
is not desirable, put \code{animation = NULL}. Otherwise, an arbitrary file name can be chosen.
\strong{Default}: \code{animation = "Fitting_of_sim_EPR"}.}

\item{...}{additional arguments specified, see also the \code{\link{eval_sim_EPR_isoFit}},
like \code{tol.step}, \code{pswarm} arguments (if \code{optim.method = "pswarm"}), \code{Blim},
\code{Intensity.expr} or \code{Intensity.sim} and \code{optim.params.fix.id}.}
}
\value{
If the \code{animation} argument is different from \code{NULL}, the function will return a \code{.gif}
  animation of the fitting procedure progress, showing the EPR spectra at each evaluation,
  based on the \code{check.fit.plot} argument. The \code{animation} file will be stored in the working directory
  of your project. Additionally, a message, appeared in the R console, informs that the animation file was created.
  Regardless of the \code{.gif} animation a list with the following elements is provided:
  \describe{
  \item{df.init.space}{A data frame object representing hyperspace of the initial EPR simulation fitting parameters
  corresponding to \code{optim.params.init} and \code{optim.params.init.dvary}. Each variable/column corresponds
  to EPR simulation parameter to be optimized and each observation/row is related to one \code{N.points.space},
  dividing the range for each parameter defined by the \code{optim.params.init.dvary}. The fitting/optimization
  is performed for each row of the \code{init.space.df}.}
  \item{df.optim.space}{Data frame object similar to \code{init.space.df}, however with optimized EPR simulation
  parameters (after the fitting procedure). In addition, the \code{optim.space.df} contains the following metrics
  of the optimization/fitting as variables/columns: sum of the residual squares \code{RSS},
  standard deviation of residuals \code{residualSD}, Akaike information criterion \code{AIC} and Bayesian information
  criterion \code{BIC}. These four parameters are actually related to optimization/fitting path
  (see the \code{plot.optim.space} below).}
  \item{plot.init.space}{A \code{ggplot2} object, corresponding to graphical representation of the \code{init.space.df}
  created by the \code{\link[ggplot2]{facet_wrap}}.}
  \item{plot.optim.space}{A \code{ggplot2} object, corresponding to graphical representation of the \code{optim.space.df}
  created by the \code{\link[ggplot2]{facet_wrap}}. One can also easily recognize the best fit/optimized parameter set,
  because the \code{Evaluation} with those parameters is highlighted by the green line. Additionally, each optimized parameter
  \emph{vs} evaluation relation is fitted by the \code{\link[stats]{loess}} function implemented
  in the \code{\link[ggplot2]{geom_smooth}} in order to show the trend and the \eqn{95\,\%} confidence interval
  of the parameter optimization. This is especially important for the \code{RSS}, \code{residualSD}, \code{AIC} and \code{BIC},
  as they represent "hills" and "valleys" of the optimization/fitting path to identify the minima.}
  \item{best.fit.params}{Vector of the best final fitting (optimized) parameters (in the \code{plot.optim.space} distinguished
  by the green line) and related to the \code{optim.params.init} argument.}
  \item{best.lineG.content}{Numeric value of the Gaussian line content of the simulated EPR spectrum.
  If \code{lineG.content.dvary = NULL}  it corresponds to the original/initial value (\code{lineG.content}).
  Otherwise, a value from the corresponding vector, defined by the \code{lineG.content} + \code{lineG.content.dvary}
  + \code{N.points.space}, and related to the \code{RSS} minimum is returned.}
  \item{plots.fit.EPRspec}{List of individual EPR spectra, depending on the \code{check.fit.plot} argument and corresponding to
  each \code{Evaluation} (refer also to the \code{plot.optim.space}). These are the actual spectra by which the animation
  was created.}
  }
}
\description{
This is an extended version of the \code{\link{eval_sim_EPR_isoFit}}, providing a broader range of the initial simulation
  parameters in order to find a more reliable simulation fit of an experimental isotropic EPR spectrum. The parameter space
  (represented by data frame/matrix and/or vector(s)) is divided into several points (see the argument \code{N.points.space})
  where each of these points corresponds to starting values (see arguments \code{optim.params.init} +
  \code{optim.params.init.dvary} as well as \code{lineG.content} + \code{lineG.content.dvary}), which are optimized
  by the \strong{default} \code{\link{eval_sim_EPR_isoFit}} \strong{setup}. Because such procedure is computationally
  highly demanding, the central loop, to iterate/evaluate parameters and the corresponding EPR spectra, uses
  the \href{https://future.apply.futureverse.org/}{\code{{future.apply}}} package
  (see also the \code{\link[future.apply]{future_Map}} function). It enables relatively seamless application
  of \href{https://nceas.github.io/oss-lessons/parallel-computing-in-r/parallel-computing-in-r.html}{parallel computing}
  (please, also refer to the \code{processing} argument),
  regardless of the operating system (OS) to dramatically speed-up the entire searching for the best fit.
  In addition to graphical outputs, function also provides an animated representation
  (using the \href{https://yihui.org/animation/}{\code{{animation}}} package) of the procedure progress
  by showing the evaluated EPR spectra.
}
\note{
In order to monitor and compare load of the hardware resources when running \code{processing = "parallel"}
  and \code{"sequential"}, one might use the following applications depending on the OS.
  For \emph{Windows}: \code{task manager} GUI (graphical user interface), for \emph{Linux}:
  terminal applications like \code{top}/\code{htop} or \code{system monitor} GUI and for \code{MacOS}
  terminal applications like \code{top}/\code{htop} or \code{activity monitor} GUI.
}
\examples{
\dontrun{
 ## run parallel processing to fit the EPR spectrum
 ## of the TMPD radical cation (+ zoom the spectrum
 ## output by `Blim`), animation
 ## "Fitting_of_sim_EPR.gif" stored in the working dir.
 listfit01 <-
   eval_sim_EPR_isoFit_space(
     data.spectr.expr = data.tmpd.spec,
     nu.GHz = data.tmpd.params.values[1,2],
     nuclear.system.noA = list(
       list("14N", 2), # 2 x 14N
       list("1H", 4), # 4 x 1H
       list("1H", 12) # 12 x 1H
     ),
     optim.params.init = c(
       2.0030, 0.4, 0.4, 0,
       2.5e5, 20.0, 5.5, 19
     ),
     optim.params.init.dvary =
     c(0.0002,0.1,0.1,0,
       2e4,2,1,2), ## or NULL
     # Nmax.evals = 256,
     # N.points.space = 16, # total number of iters. 4096
     lineG.content = 0.3,
     lineG.content.dvary = 0.15, ## or NULL
     # optim.method = "neldermead",
     processing = "parallel" , ## or "sequential"
     Blim = c(3455,3545)
 )
 #
 ## optimization/fitting progress
 ## (main graphical output)
 listfit01$plot.optim.space
 #
 ## run the similar processing and evaluation
 ## like before, but now with the fixed g-value
 ## (will be not optimized) and with 24 `N.points.space`
 listFit02 <-
    eval_sim_EPR_isoFit_space(
      data.spectr.expr = data.tmpd.spec,
      nu.GHz = data.tmpd.params.values[1,2],
      nuclear.system.noA = list(
        list("14N", 2), # 2 x 14N
        list("1H", 4), # 4 x 1H
        list("1H", 12) # 12 x 1H
      ),
      optim.params.init = c(
        2.00305, 0.4, 0.4, 0,
        1.25e4, 20.0, 5.5, 19
      ),
      optim.params.init.dvary =
      c(0,0.1,0.1,0, # `.dvary` for g-value = 0
        2e3,2,1,2),
      # Nmax.evals = 256,
      N.points.space = 24, # total number of iters. 6144
      lineG.content = 0.3,
      lineG.content.dvary = 0.15,
      processing = "parallel" ,
      optim.params.fix.id = 1, # fix g-value
      Blim = c(3455,3545)
    )
  #
  ## space (plot) for initial parameters:
  listFit02$plot.init.space
  #
  ## space (plot) for optimized parameters
  listFit02$plot.optim.space
}


}
\seealso{
Other Simulations and Optimization: 
\code{\link{eval_ABIC_forFit}()},
\code{\link{eval_sim_EPR_iso}()},
\code{\link{eval_sim_EPR_isoFit}()},
\code{\link{eval_sim_EPR_iso_combo}()},
\code{\link{optim_for_EPR_fitness}()},
\code{\link{plot_eval_EPRtheo_mltiplet}()},
\code{\link{plot_eval_RA_forFit}()},
\code{\link{quantify_EPR_Sim_series}()},
\code{\link{smooth_EPR_Spec_by_npreg}()}
}
\concept{Simulations and Optimization}
