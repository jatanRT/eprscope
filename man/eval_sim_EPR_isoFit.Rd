% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eval_sim_EPR_isoFit.R
\name{eval_sim_EPR_isoFit}
\alias{eval_sim_EPR_isoFit}
\title{Least-Squares Fitting of Isotropic EPR spectra by Simulations}
\usage{
eval_sim_EPR_isoFit(
  data.spectr.expr,
  Intensity.expr = "dIepr_over_dB",
  Intensity.sim = "dIeprSim_over_dB",
  nu.GHz,
  B.unit = "G",
  nuclear.system.noA = NULL,
  baseline.correct = "constant",
  lineG.content = 0.5,
  lineSpecs.form = "derivative",
  optim.method = "neldermead",
  optim.params.init,
  optim.params.lower = NULL,
  optim.params.upper = NULL,
  Nmax.evals = 1024,
  tol.step = 5e-07,
  pswarm.size = NULL,
  pswarm.diameter = NULL,
  check.fit.plot = TRUE,
  output.list.final = FALSE,
  ...
)
}
\arguments{
\item{data.spectr.expr}{Data frame object/table, containing the experimental spectral data the with magnetic flux density
(\code{"B_mT"} or \code{"B_G"}) and the intensity (see the \code{Intensity.expr} argument) columns.}

\item{Intensity.expr}{Character string, pointing to column name of the experimental EPR intensity within
the original \code{data.spectr.expr}. \strong{Default}: \code{dIepr_over_dB}.}

\item{Intensity.sim}{Character string, pointing to column name of the simulated EPR intensity within the related output
data frame. \strong{Default}: \code{Intensity.sim = "dIeprSim_over_dB"}.}

\item{nu.GHz}{Numeric value, microwave frequency in \code{GHz}.}

\item{B.unit}{Character string, denoting the magnetic flux density unit e.g. \code{B.unit = "G"}
(gauss, \strong{default}) or \code{B.unit = "mT"}/\code{"T"} (millitesla/tesla).}

\item{nuclear.system.noA}{List or nested list \strong{without estimated hyperfine coupling constant values},
such as \code{list("14N",1)} or \code{list(list("14N", 2),list("1H", 4),list("1H", 12))}. The \eqn{A}-values
are already defined as elements of the \code{optim.params.init} argument/vector. If the EPR spectrum
does not display any hyperfine splitting, the argument definition reads \code{nuclear.system.noA = NULL} (\strong{default}).}

\item{baseline.correct}{Character string, referring to baseline correction of the simulated/fitted spectrum.
Corrections like \code{"constant"} (\strong{default}), \code{"linear"} or \code{"quadratic"} can be applied.}

\item{lineG.content}{Numeric value between \code{0} and \code{1}, referring to content of \emph{Gaussian} line form.
If \code{lineG.content = 1} (\strong{default}) it corresponds to "pure" \emph{Gaussian} line form
and if \code{lineG.content = 0} it corresponds to \emph{Lorentzian} one. The value from (0,1)
(e.g. \code{lineG.content = 0.5}) represents the linear combination (for the example above
with the coefficients 0.5 and 0.5) of both line forms => so called \emph{pseudo-Voigt}.}

\item{lineSpecs.form}{Character string, describing either \code{"derivative"} (\strong{default})
or \code{"integrated"} (i.e. \code{"absorption"} which can be used as well) line form
of the analyzed EPR spectrum/data.}

\item{optim.method}{Character string (vector), setting the optimization method(s) gathered within
the \code{\link{optim_for_EPR_fitness}}. \strong{Default}: \code{optim.method = "neldermead"}. Additionally,
several consecutive methods can be defined like \code{optim.method = c("levenmarq","neldermead")}, where
the best fit parameters from the previous method are used as input for the next one. In such case, the output
is \code{list} with the elements/vectors from each method, in order to see the progress of the optimization.}

\item{optim.params.init}{Numeric vector with the initial parameter guess (elements) where the \strong{first five
  elements are immutable}
  \enumerate{
  \item g-value (g-factor)

  \item \strong{G}aussian linewidth

  \item \strong{L}orentzian linewidth

  \item baseline constant (intercept)

  \item intensity multiplication constant

  \item baseline slope (only if \code{baseline.correct = "linear"} or \code{baseline.correct = "quadratic"}),
  if \code{baseline.correct = "constant"} it corresponds to the \strong{first HFCC} (\eqn{A_1})

  \item baseline quadratic coefficient (only if \code{baseline.correct = "quadratic"}),
  if \code{baseline.correct = "constant"} it corresponds to the \strong{second HFCC} (\eqn{A_2}),
  if \code{baseline.correct = "linear"} it corresponds to the \strong{first HFCC} (\eqn{A_1})

  \item additional HFCC (\eqn{A_3}) if \code{baseline.correct = "constant"} or if
  \code{baseline.correct = "linear"} (\eqn{A_2}), if \code{baseline.correct = "quadratic"} it corresponds
  to the \strong{first HFCC} (\eqn{A_1})

  \item ...additional HFCCs (\eqn{A_k...}, each vector element is reserved only for one \eqn{A})
  }
  DO NOT PUT ANY OF THESE PARAMETERS to \code{NULL}. If the lineshape is expected to be pure
  \strong{L}orentzian or pure \strong{G}aussian then put the corresponding vector element to \code{0}.}

\item{optim.params.lower}{Numeric vector (with the same element order like \code{optim.params.init})
with the lower bound constraints. \strong{Default}: \code{optim.params.lower = NULL} which actually
equals to \eqn{g_{\text{init}} - 0.001}, \eqn{0.8\,\Delta B_{\text{G,init}}},
\eqn{0.8\,\Delta B_{\text{L,init}}}, baseline intercept initial constant \eqn{- 0.001},
intensity multiplication initial constant \eqn{= 0.8\,\text{init}}, baseline initial slope \eqn{- 5} (in case
the \code{baseline.correct} is set either to \code{"linear"} or \code{"quadratic"}) and finally,
the baseline initial quadratic coefficient \eqn{- 5} (in case the \code{baseline.correct} is set to
\code{"quadratic"}). Lower limits of all hyperfine coupling constant (HFCCs) are set to \eqn{0.9\,A_{\text{init}}}.}

\item{optim.params.upper}{Numeric vector (with the same element order like \code{optim.params.init})
with the upper bound constraints. \strong{Default}: \code{optim.params.upper = NULL} which actually
equals to \eqn{g_{\text{init}} + 0.001}, \eqn{1.2\,\Delta B_{\text{G,init}}},
\eqn{1.2\,\Delta B_{\text{L,init}}}, baseline intercept initial constant \eqn{+ 0.001},
intensity multiplication initial constant \eqn{= 1.2\,\text{init}}, baseline initial slope \eqn{+ 5} (in case
the \code{baseline.correct} is set either to \code{"linear"} or \code{"quadratic"}) and finally,
the baseline initial quadratic coefficient \eqn{+ 5} (in case the \code{baseline.correct} is set to
\code{"quadratic"}). Upper limits of all HFCCs are set to \eqn{1.1\,A_{\text{init}}}.}

\item{Nmax.evals}{Numeric value, pointing to maximum number of iterations/evaluations. \strong{Default}:
\code{Nmax.evals = 1024} (for \code{optim.method = "levenmarq"} this is the maximum value).}

\item{tol.step}{Numeric value, describing the smallest optimization step (tolerance) to stop the optimization.
\strong{Default}: \code{tol.step = 5e-7}.}

\item{pswarm.size}{Numeric value, which equals to particle swarm size (i.e. number of particles),
if \code{method = "pswarm"}. The \strong{default} value (\code{pswarm.size = NULL}) actually
corresponds to \code{floor(10+2*sqrt(length(x.0)))}, e.g. to optimize 8 parameters,
number of particles = 15.}

\item{pswarm.diameter}{Numeric value, corresponding to diameter of the particle swarm search space
(in case \code{method = "pswarm"}). The \strong{default} value (\code{pswarm.diameter = NULL})
refers to the Euclidean distance, defined as:
\deqn{\sqrt{\sum_k\,(\text{optim.params.upper}[k] - \text{optim.params.lower}[k])^2}}}

\item{check.fit.plot}{Logical, whether to return overlay plot with the initial simulation + the best simulation
fit + experimental spectrum (including residuals in the lower part of the plot,
\code{check.fit.plot = TRUE}, \strong{default}) or with the following three spectra
(\code{check.fit.plot = FALSE}): 1. experimental, 2. the best simulated one with the baseline fit
and 3. the best simulated spectrum with the baseline fit subtracted. The latter two are offset for clarity,
within the plot.}

\item{output.list.final}{Logical. If \code{TRUE}, \code{list} with the following components will be exclusively returned:
1. optimized parameters from the best fit (together with the minimum sum of residual squares)
and 2. data frame of the final best simulated spectrum with and without the baseline fit (see \code{Value}).
Such output will be applied for the more complex optimization/fitting (which is currently under development),
as stated in the \code{Description}, therefore, the \strong{default} value reads \code{output.list.final = FALSE}.}

\item{...}{additional arguments specified (see also \code{\link{optim_for_EPR_fitness}}).}
}
\value{
Optimization/Fitting procedure results in vector or data frame or list depending on the \code{check.fit.plot}
  and \code{output...} arguments.
  \enumerate{
  \item If \code{check.fit.plot = TRUE} or \code{check.fit.plot = FALSE}, the result corresponds
  to list with the following components:
  \describe{
  \item{plot}{Visualization of the experimental as well as the best fitted EPR simulated spectra.
  If \code{check.fit.plot = TRUE}, the overlay plot consists of the initial simulation + the best simulation
  fit + experimental spectrum, including residuals in the plot lower part. Whereas, if \code{check.fit.plot = FALSE},
  following three spectra are available: 1. experimental, 2. the best simulated one with the baseline fit
  and 3. the best simulated spectrum with the baseline fit subtracted. The latter two are offset for clarity.}
  \item{best.fit.params}{Vector of the best (final) fitting (optimized) parameters, for each corresponding
  \code{optim.method}, to simulate the experimental EPR spectrum, see also description of the \code{optim.params.init}.}
  \item{df}{Tidy data frame (table) with the magnetic flux density and intensities of the experimental,
  the best simulated/fitted, as well as the initially simulated EPR spectrum and residuals
  (if \code{check.fit.plot = TRUE}), or wide data frame with the following variables / columns
  (for \code{check.fit.plot = FALSE}): magnetic flux density, intensity of the experimental
  spectrum, intensity of the best simulated one (including the baseline fit), residual intensity and finally,
  the best simulated spectrum intensity without the baseline fit.}
  \item{sum.LSQ.min}{The minimum sum of the residual square vector after the least-square
  procedure.}
  \item{N.evals}{Number of iterations/function evaluations completed before termination.
  If the \code{pswarm} optimization algorithm is included in \code{optim.method}, the \code{N.evals}
  equals to vector with the following elements: number of function evaluations, number of iterations (per one particle)
  and the number of restarts.}
  \item{N.converg}{Vector or simple integer code indicating the successful completion
  of the optimization/fit. In the case of \code{"levenmarq"} method, the vector elements coincide with
  the sum of residual squares at each iteration. If the \code{optim.method = "pswarm"} is applied, one of the following
  codes can be returned: \code{0}: algorithm terminated by reaching the absolute tolerance,
  \code{1}: maximum number of function evaluations reached, \code{2}: maximum number of iterations reached,
  \code{3}: maximum number of restarts reached, \code{4}: maximum number of iterations without improvement reached.
  For all the other remaining methods (coming from \code{{nloptr}} package), the integers have to be positive
  to indicate the successful convergence.}
  }

  \item If \code{output.list.final = TRUE}, the function exclusively returns list with the two components,
  which will be applied for the more complex optimization/fitting (which is currently under development).
  \describe{
  \item{params}{Vector, corresponding to the best fitting (optimized) parameters (related
  to the \code{optim.params.init} argument, see also list above) + minimum sum of the residual squares,
  after the (final) \code{optim.method} procedure.}
  \item{df}{Data frame including the final best simulated spectrum with and without the baseline fit.}
  }
  }
}
\description{
Fitting of the simulated spectrum onto the experimental one represents an important step in the analysis
  of EPR spectra. Parameters of the simulated spectrum like \eqn{g_{\text{iso}}}; coupling constants
  (in \code{MHz}) \eqn{A_{\text{iso}}} for each group of equivalent nuclei; linewidth
  (either \eqn{\Delta B_{\text{pp}}} or \eqn{FWHM} depending on \code{lineSpecs.form});
  spectral baseline (see the \code{baseline.correct}) and finally the intensity (multiplication coefficient)
  are optimized by the methods listed in \code{\link{optim_for_EPR_fitness}}.
  The \code{lineG.content} corresponding parameter is the only one,
  which needs to be varied "manually". In order to control the optimization/fitting process,
  by similar interactive way like in \href{https://easyspin.org/easyspin/documentation/userguide_fitting.html}{EasySpin},
  a \href{https://www.rstudio.com/products/shiny/}{Shiny app}
  and/or \href{https://gganimate.com/}{{gganimate}} visualization is under development.
}
\note{
In order to guess the intensity multiplication constant (please, refer to the \code{optim.params.init}
  argument), one might compare the intensities of the experimental (\code{expr}) and simulated (\code{sim})
  EPR spectrum by one of the interactive or static plot functions (e.g. \code{\link{plot_EPR_Specs}}
  or \code{\link{plot_EPR_Specs2D_interact}}) as well as by the \code{\link{eval_sim_EPR_iso}}. Accordingly,
  \strong{the initial intensity multiplication constant} can be estimated as the ratio
  \strong{max(\code{expr} intensity)/max(\code{sim} intensity)}.
}
\examples{
## loading built-in example dataset which is simple
## EPR spectrum of the aminoxyl radical:
aminoxyl.data.path <-
  load_data_example(file = "Aminoxyl_radical_a.txt")
aminoxyl.data <-
  readEPR_Exp_Specs(aminoxyl.data.path,
                    qValue = 2100)
#
## EPR spectrum simulation fit with "Nelder-Mead"
## optimization method with `check.fit.plot = FALSE`:
tempo.test.sim.fit.a <-
  eval_sim_EPR_isoFit(data.spectr.expr = aminoxyl.data,
    nu.GHz = 9.806769,
    lineG.content = 0.5,
    optim.method = "neldermead",
    nuclear.system.noA = list("14N",1),
    baseline.correct = "linear",
    optim.params.init =
      c(2.006, # g-value
        4.8, # G Delta Bpp
        4.8, # L Delta Bpp
        0, # intercept (constant) lin. baseline
        0.016, # Sim. intensity multiply
        1e-6, # slope lin. baseline
        49), # A in MHz
    check.fit.plot = FALSE
  )
## OUTPUTS RETURNED:
## best fit parameters:
tempo.test.sim.fit.a$best.fit.params
#
## spectrum plot with experimental spectrum,
## simulated one with the linear baseline fit
## and simulated one with the linear baseline
## fit subtracted:
tempo.test.sim.fit.a$plot
#
## minimum sum of squared residuals:
tempo.test.sim.fit.a$sum.LSQ.min
#
## number of evaluations / iterations:
tempo.test.sim.fit.a$N.evals
#
## convergence, in this case it is represented
## by the integer code indicating the successful
## completion (it must be > 0):
tempo.test.sim.fit.a$N.converg
#
## preview of data frame including all EPR spectra:
head(tempo.test.sim.fit.a$df)
#
## similar EPR spectrum simulation fit with "particle swarm"
## optimization algorithm and `check.fit.plot = TRUE` option
## as well as user defined bound constraints:
tempo.test.sim.fit.b <-
  eval_sim_EPR_isoFit(data.spectr.expr = aminoxyl.data,
    nu.GHz = 9.806769,
    lineG.content = 0.4,
    optim.method = "pswarm",
    nuclear.system.noA = list("14N",1),
    baseline.correct = "constant",
    optim.params.init = c(2.006,4.8,4.8,0,1.1e-2,49),
    optim.params.lower = c(2.0048,4.4,4.4,-1e-4,9e-3,45),
    optim.params.upper = c(2.0072,5.2,5.2,1e-4,1.5e-2,53),
    check.fit.plot = TRUE
  )
## OUTPUTS-RETURN:
## best fit parameters:
tempo.test.sim.fit.b$best.fit.params
#
## quick simulation check by plotting the both
## simulated and the experimental EPR spectra
## together with the initial simulation
## and the residuals (differences between the
## experiment and the best fit)
tempo.test.sim.fit.b$plot
#
## fitting of the aminoxyl EPR spectrum
## by the combination of the 1. "Levenberg-Marquardt"
## and 2. "Nelder-Mead" algorithms
tempo.test.sim.fit.c <-
  eval_sim_EPR_isoFit(aminoxyl.data,
                      nu.GHz = 9.86769,
                      lineG.content = 0.5,
                      optim.method = c("levenmarq",
                                       "neldermead"),
                      nuclear.system.noA = list("14N",1),
                      baseline.correct = "constant",
                      optim.params.init = c(2.0060,
                                            4.8,
                                            4.8,
                                            0,
                                            7e-3,
                                            49),
                      check.fit.plot = FALSE
                    )
## OUTPUTS RETURNED:
## best fit parameters for both procedures within a list:
tempo.test.sim.fit.c$best.fit.params
#
## compare the results with the example in the `readMAT_params_file`,
## corresponding to the best fit from `Easyspin`
#
## `N.converg` also consists of two components
## each corresponding to result of the individual
## optimization method where the "levenmarq" returns
## the sum of squares at each iteration, therefore the 1st
## component is vector and the 2nd one is integer code
## as already stated above:
tempo.test.sim.fit.c$N.converg


}
\seealso{
Other Simulations and Optimization: 
\code{\link{eval_sim_EPR_iso}()},
\code{\link{eval_sim_EPR_iso_combo}()},
\code{\link{optim_for_EPR_fitness}()},
\code{\link{quantify_EPR_Sim_series}()},
\code{\link{smooth_EPR_Spec_by_npreg}()}
}
\concept{Simulations and Optimization}
