% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eval_sim_EPR_isoFit.R
\name{eval_sim_EPR_isoFit}
\alias{eval_sim_EPR_isoFit}
\title{Least-Squares Fitting of Isotropic EPR spectra by Simulations}
\usage{
eval_sim_EPR_isoFit(
  data.spectr.expr,
  Intensity.expr = "dIepr_over_dB",
  Intensity.sim = "dIeprSim_over_dB",
  nu.GHz,
  B.unit = "G",
  nuclear.system.noA,
  baseline.correct = "constant",
  lineG.content = 0.5,
  lineSpecs.form = "derivative",
  optim.method = "neldermead",
  optim.params.init,
  optim.params.lower = NULL,
  optim.params.upper = NULL,
  Nmax.evals = 1024,
  tol.step = 5e-07,
  pswarm.size = NULL,
  pswarm.diameter = NULL,
  sim.check = TRUE
)
}
\arguments{
\item{data.spectr.expr}{Data frame object ... TBC ...}

\item{Intensity.expr}{Character string ... TBC ...}

\item{Intensity.sim}{Character string ... TBC ...}

\item{nu.GHz}{Numeric value, microwave frequency in \code{GHz}.}

\item{B.unit}{Character string denoting the magnetic flux density unit e.g. \code{B.unit = "G"}
(gauss, \strong{default}) or \code{B.unit = "mT"} (millitesla). These are the usual units used
for EPR spectra. Additionally, \code{B.unit = "T"} (tesla) can be set as well.}

\item{nuclear.system.noA}{List or nested list ... TBC ... without estimated hyperfine coupling constant values}

\item{baseline.correct}{Character string ...}

\item{lineG.content}{Numeric value ...}

\item{lineSpecs.form}{Character string ...}

\item{optim.method}{Character string ... TBC ...}

\item{optim.params.init}{Numeric vector with the initial parameter guess (elements) where the \strong{first five
  elements are immutable}
  \enumerate{
  \item g-value (g-factor)

  \item \strong{G}aussian linewidth

  \item \strong{L}orentzian linewidth

  \item baseline constant (intercept)

  \item intensity multiplication constant

  \item baseline slope (only if \code{baseline.correct = "linear"} or \code{baseline.correct = "quadratic"}),
  if \code{baseline.correct = "constant"} it corresponds to the \strong{first HFCC} (\eqn{A_1})

  \item baseline quadratic coefficient (only if \code{baseline.correct = "quadratic"}),
  if \code{baseline.correct = "constant"} it corresponds to the \strong{second HFCC} (\eqn{A_2}),
  if \code{baseline.correct = "linear"} it corresponds to the \strong{first HFCC} (\eqn{A_1})

  \item additional HFCC (\eqn{A_3}) if \code{baseline.correct = "constant"} or if
  \code{baseline.correct = "linear"} (\eqn{A_2}), if \code{baseline.correct = "quadratic"} it corresponds
  to the \strong{first HFCC} (\eqn{A_1})

  \item ...additional HFCCs (\eqn{A_k...}, each vector element is reserved only for one \eqn{A})
  }
  DO NOT PUT ANY OF THESE PARAMETERS to \code{NULL}. If the lineshape is expected to be pure
  \strong{L}orentzian or pure \strong{G}aussian then put the corresponding vector element to \code{0}.}

\item{optim.params.lower}{Numeric vector (with the same element order like \code{optim.params.init})
with the lower bound constraints. \strong{Default}: \code{optim.params.lower = NULL} which actually
equals to \eqn{g_{\text{init}} - 0.001}, \eqn{0.8\,\Delta B_{\text{G,init}}},
\eqn{0.8\,\Delta B_{\text{L,init}}}, baseline intercept initial constant \eqn{- 0.001},
intensity multiplication initial constant \eqn{= 1\cdot 10^{-8}}, baseline initial slope \eqn{- 5} (in case
the \code{baseline.correct} is set either to \code{"linear"} or \code{"quadratic"}) and finally,
the baseline initial quadratic coefficient \eqn{- 5} (in case the \code{baseline.correct} is set to
\code{"quadratic"}). Lower limits of all hyperfine coupling constant are set to \eqn{0.9\,A_{\text{init}}}.}

\item{optim.params.upper}{Numeric vector (with the same element order like \code{optim.params.init})
with the upper bound constraints. \strong{Default}: \code{optim.params.upper = NULL} which actually
equals to \eqn{g_{\text{init}} + 0.001}, \eqn{1.2\,\Delta B_{\text{G,init}}},
\eqn{1.2\,\Delta B_{\text{L,init}}}, baseline intercept initial constant \eqn{+ 0.001},
intensity multiplication initial constant \eqn{= 100}, baseline initial slope \eqn{+ 5} (in case
the \code{baseline.correct} is set either to \code{"linear"} or \code{"quadratic"}) and finally,
the baseline initial quadratic coefficient \eqn{+ 5} (in case the \code{baseline.correct} is set to
\code{"quadratic"}). Upper limits of all hyperfine coupling constant are set to \eqn{1.1\,A_{\text{init}}}.}

\item{Nmax.evals}{Numeric value pointing to maximum number of iterations/evaluations. \strong{Default}:
\code{Nmax.evals = 1024} (for \code{optim.method = "levenmarq"} this is the maximal value).}

\item{tol.step}{Numeric value describing the smallest optimization step (tolerance) to stop the optimization.
\strong{Default}: \code{tol.step = 5e-7}.}

\item{pswarm.size}{Numeric value equal to particle swarm size (i. e. number of particles), only
if \code{optim.method = "pswarm"}. Otherwise, \code{pswarm.size = NULL} (\strong{default}).}

\item{pswarm.diameter}{Numeric value corresponding to diameter of the particle swarm search space
(in case \code{optim.method = "pswarm"}). The \strong{default} value (\code{pswarm.diameter = NULL})
refers to the Euclidian distance, defined as:
\deqn{\sqrt{\sum_k\,(\text{optim.params.upper}_k - \text{optim.params.lower}_k)^2}}}

\item{sim.check}{Logical, whether to return simple list with the overlay (simulated + experimental
spectrum) as well as residual plot and the best fitting parameters in a vector
(\code{sim.check = TRUE}, \strong{default}). If \code{sim.check = FALSE} the list contains
EPR spectra, data frame, best fitting parameters as well as additional statistical measures
of the optimization/fitting procedure (see \code{Value}).}
}
\value{
List with following components depending on \code{sim.check}:
  \enumerate{
  \item if \code{sim.check = TRUE} it returns list with two components:
  \describe{
  \item{plot}{Visualization of the experimental as well as the best fitted EPR simulated spectrum
  in "overlay" mode. Additional graph, below to the latter, showing the residuals (difference between
  the experimental and the fitted simulated EPR spectrum) after the optimization / fitting procedure
  in order to quickly evaluate the quality of the fit.}
  \item{best.fit.params}{Vector of the best (final) fitting parameters to simulate the EPR spectrum,
  see also description of the \code{optim.params.init}.}
  }

  \item if \code{sim.check = FALSE} it returns list with the following components:
  \describe{
  \item{plot}{Visualization of three spectra which are offset for clarity. The first
  (the upper one) is the original experimental spectrum. The second one (in the middle)
  is the best fitted spectrum together with its baseline counterpart. Finally, the 3rd one
  corresponds to the best fitted spectrum where the baseline counter part was subtracted.}
  \item{best.fit.params}{Vector of the best (final) fitting parameters to simulate the EPR spectrum,
  see also description of the \code{optim.params.init}.}
  \item{df}{Data frame (table) with the following variables / columns: magnetic flux density,
  intensity of the experimental spectrum, intensity of the simulated spectrum (including
  the baseline fit), residual intensity of the fit and finally, simulated spectrum intensity
  without the baseline fit.}
  \item{sum.LSQ.min}{The minimal sum of the residual square vector after the least-square
  procedure.}
  \item{N.evals}{Number of iterations/function evaluations completed before termination.
  If the \code{pswarm} optimization algorithm is included in \code{optim.method}, the \code{N.evals}
  equals to vector with the following elements: number of function evaluations, number of iterations
  and the number of restarts.}
  \item{N.converg}{Vector or simple integer code indicating the successful completion
  of the optimization/fit. If the ...TBC...}
  }
  }
}
\description{
A short description...
}
\details{
Additional details...
}
\examples{
## loading built-in example dataset which is simple
## EPR spectrum of the aminoxyl radical:
aminoxyl.data.path <-
 load_data_example(file = "Aminoxyl_radical_a.txt")
aminoxyl.data <-
 readEPR_Exp_Specs(aminoxyl.data.path,qValue = 2100)
#
## EPR spectrum simulation fit with "Nelder-Mead"
## optimization method with `sim.check = FALSE`:
tempo.test.sim.fit.a <-
eval_sim_EPR_isoFit(data.spectr.expr = aminoxyl.data,
                    nu.GHz = 9.806769,
                    lineG.content = 0.5,
                    optim.method = "neldermead",
                    nuclear.system.noA = list("14N",1),
                    baseline.correct = "linear",
                    optim.params.init =
                    c(2.006, # g-value
                      4.8, # G Delta Bpp
                      4.8, # L Delta Bpp
                      0, # intercept (constant) lin. baseline
                      0.008, # Sim. intensity multiply
                      1e-6, # slope lin. baseline
                      49), # A in MHz
                    sim.check = FALSE)
## OUTPUTS-RETURN:
## best fit parameters:
tempo.test.sim.fit.a$best.fit.params
#
## spectrum plot with experimental spectrum,
## simulated one with the linear baseline fit
## and simulated one with the linear baseline
## fit subtracted:
tempo.test.sim.fit.a$plot
#
## minimal sum of squared residuals:
tempo.test.sim.fit.a$sum.LSQ.min
#
## number of evaluations / iterations:
tempo.test.sim.fit.a$N.evals
#
## convergence, in this case it is represented
## by the integer code indicating the successful
## completion (it must be > 0):
tempo.test.sim.fit.a$N.converg
#
## preview of data frame including all spectra:
head(tempo.test.sim.fit.a$df)
#
## similar EPR spectrum simulation fit with "particle swarm"
## optimization algorithm and `sim.check = TRUE` option
## as well as user defined bound constraints:
tempo.test.sim.fit.b <-
eval_sim_EPR_isoFit(data.spectr.expr = aminoxyl.data,
                    nu.GHz = 9.806769,
                    lineG.content = 0.4,
                    optim.method = "pswarm",
                    nuclear.system.noA = list("14N",1),
                    baseline.correct = "constant",
                    optim.params.init = c(2.006,4.8,4.8,0,7e-3,49),
                    optim.params.lower = c(2.0048,4.4,4.4,-1e-4,4e-3,45),
                    optim.params.upper = c(2.0072,5.2,5.2,1e-4,1e-2,53),
                    sim.check = TRUE)
## OUTPUTS-RETURN:
## best fit parameters:
tempo.test.sim.fit.b$best.fit.params
#
## quick simulation check by plotting the both
## simulated and the experimental EPR spectra together
## with the residuals (differences between the both latter):
tempo.test.sim.fit.b$plot
#
## fitting of the aminoxyl EPR spectrum by the combination
## of the 1. "Levenberg-Marquardt" and 2. "Nelder-Mead" algorithms
tempo.test.sim.fit.c <-
eval_sim_EPR_isoFit(aminoxyl.data,
                    nu.GHz = 9.86769,
                    lineG.content = 0.5,
                    optim.method = c("levenmarq",
                                     "neldermead"),
                    nuclear.system.noA = list("14N",1),
                    baseline.correct = "constant",
                    optim.params.init = c(2.0060,
                                          4.8,
                                          4.8,
                                          0,
                                          7e-3,
                                          49),
                    sim.check = FALSE
                    )
## OUTPUTS-RETURN:
## best fit parameters for both procedures within a list:
tempo.test.sim.fit.c$best.fit.params
#
## `N.converg` also consists of two components
## each corresponding to result of the individual
## optimization method where the "levenmarq" returns
## sum of squares at each iteration, therefore the 1st
## component is vector and the 2nd one is integer code
## as already stated above:
tempo.test.sim.fit.c$N.converg


}
\seealso{
Other Simulations and Optimization: 
\code{\link{eval_sim_EPR_iso}()},
\code{\link{eval_sim_EPR_iso_combo}()},
\code{\link{optim_for_EPR_fitness}()},
\code{\link{quantify_EPR_Sim_series}()},
\code{\link{smooth_EPR_Spec_by_npreg}()}
}
\concept{Simulations and Optimization}
